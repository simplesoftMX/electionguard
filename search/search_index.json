{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ElectionGuard is an open source software development kit (SDK) that makes voting more secure, transparent and accessible. Announced on at the Build developer conference , ElectionGuard enables end-to-end verification of elections as well as support the publication of results from ballot comparison audits. The ElectionGuard SDK leverages homomorphic encryption to ensure that votes recorded by electronic systems of any type remain encrypted, secure, and secret. Results can be published online or made available to third-party organizations for secure validation, and allow individual voters to confirm their votes were correctly counted. Important First time to ElectionGuard? Check out our Getting Started or our Guide . Open-Source This library and all linked ElectionGuard projects, are licensed under the MIT license. There is no fee for using ElectionGuard. Security Issues Reporting We encourage the developer and security community to conduct research, report issues, and suggest improvements on this code base. However, unlike performance or feature bugs, please do not report security vulnerabilities in public Github comments. Each repository has a SECURITY file with instructions on responsibly reporting security vulnerabilities under Microsoft's CVD process. Contributing Help defend democracy and contribute to the project . Questions ElectionGuard would love for you to ask questions out in the open using Github Issues. If you really want to email the ElectionGuard team, reach out at electionguard@microsoft.com . Thanks A huge thank you to those who helped to contribute to this project so far, including: Josh Benaloh (whose PhD thesis was the genesis of much of this work) InfernoRed Technology VotingWorks Center for Civic Design Oxide Design Many teams within Microsoft","title":"About"},{"location":"#_1","text":"ElectionGuard is an open source software development kit (SDK) that makes voting more secure, transparent and accessible. Announced on at the Build developer conference , ElectionGuard enables end-to-end verification of elections as well as support the publication of results from ballot comparison audits. The ElectionGuard SDK leverages homomorphic encryption to ensure that votes recorded by electronic systems of any type remain encrypted, secure, and secret. Results can be published online or made available to third-party organizations for secure validation, and allow individual voters to confirm their votes were correctly counted. Important First time to ElectionGuard? Check out our Getting Started or our Guide .","title":""},{"location":"#open-source","text":"This library and all linked ElectionGuard projects, are licensed under the MIT license. There is no fee for using ElectionGuard.","title":"Open-Source"},{"location":"#security-issues-reporting","text":"We encourage the developer and security community to conduct research, report issues, and suggest improvements on this code base. However, unlike performance or feature bugs, please do not report security vulnerabilities in public Github comments. Each repository has a SECURITY file with instructions on responsibly reporting security vulnerabilities under Microsoft's CVD process.","title":"Security Issues Reporting"},{"location":"#contributing","text":"Help defend democracy and contribute to the project .","title":"Contributing"},{"location":"#questions","text":"ElectionGuard would love for you to ask questions out in the open using Github Issues. If you really want to email the ElectionGuard team, reach out at electionguard@microsoft.com .","title":"Questions"},{"location":"#thanks","text":"A huge thank you to those who helped to contribute to this project so far, including: Josh Benaloh (whose PhD thesis was the genesis of much of this work) InfernoRed Technology VotingWorks Center for Civic Design Oxide Design Many teams within Microsoft","title":"Thanks"},{"location":"Getting_Started/","text":"Getting Started There are many places to start start in ElectionGuard. If you're looking to develop see below, if you just want to research see the guide . Latest These are the latest projects from ElectionGuard. If you're looking to contribute, these are the best places to start. electionguard-python electionguard-web-api Language Pick your language of preference:","title":"Overview"},{"location":"Getting_Started/#getting-started","text":"There are many places to start start in ElectionGuard. If you're looking to develop see below, if you just want to research see the guide .","title":"Getting Started"},{"location":"Getting_Started/#latest","text":"These are the latest projects from ElectionGuard. If you're looking to contribute, these are the best places to start. electionguard-python electionguard-web-api","title":"Latest"},{"location":"Getting_Started/#language","text":"Pick your language of preference:","title":"Language"},{"location":"Hacktoberfest/","text":"Hacktoberfest is an event to encourage participation in the open source community. We're glad to be participating in Hacktoberfest 2020! We love being engaged in the community and we hope you'll join in. Here are some resources to engage with ElectionGuard during Hacktoberfest. Happy hacking! Ways to Participate Create a pull request for an issue in our participating repositories electionguard-python electionguard-web-api Build a Hacktoberfest Verifier Create Hacktoberfest Verifier Help us verify elections end-to-end by creating your own verifier. We'll get you started with some instructions and election files. Check out the Hacktoberfest Verifier issue Code your verifier Push it to GitHub Create a PR to add your name and repo to the list below Election Verifiers When you're finished, create a PR and add your name & verifier to this list Your Name - [Verifier Name](Repository Link)","title":"Hacktoberfest"},{"location":"Hacktoberfest/#ways-to-participate","text":"Create a pull request for an issue in our participating repositories electionguard-python electionguard-web-api Build a Hacktoberfest Verifier","title":"Ways to Participate"},{"location":"Hacktoberfest/#create-hacktoberfest-verifier","text":"Help us verify elections end-to-end by creating your own verifier. We'll get you started with some instructions and election files. Check out the Hacktoberfest Verifier issue Code your verifier Push it to GitHub Create a PR to add your name and repo to the list below","title":"Create Hacktoberfest Verifier"},{"location":"Hacktoberfest/#election-verifiers","text":"When you're finished, create a PR and add your name & verifier to this list Your Name - [Verifier Name](Repository Link)","title":"Election Verifiers"},{"location":"guide/Core_Component/","text":"There are various implementations of the core component of the ElectionGuard SDK. This piece performs election functions such as vote encryption, decryption, key generation, and tallying. This code is meant to be run on voting system hardware and to be integrated into existing (or new) voting system software. The ElectionGuard SDK is meant to add end-to-end verifiability and encryption into 3rd party comprehensive voting systems. There are provided simplistic, proof-of-concept applications to understand how each implementation of the API should be called. Currently, there are two available implementations. Python Includes: Key Generation, Ballot Encryption, Tallying, Decryption Source | Package | Documentation C ++ Includes: Ballot Encryption Source - \u2728 Coming Soon Archived Danger The following versions and their dependent repositories are considered deprecated. For active development, please use a non-archived version instead. C Source C# Source | Package","title":"Core Component"},{"location":"guide/Core_Component/#python","text":"Includes: Key Generation, Ballot Encryption, Tallying, Decryption Source | Package | Documentation","title":"Python"},{"location":"guide/Core_Component/#c","text":"Includes: Ballot Encryption Source - \u2728 Coming Soon","title":"C ++"},{"location":"guide/Core_Component/#archived","text":"Danger The following versions and their dependent repositories are considered deprecated. For active development, please use a non-archived version instead.","title":"Archived"},{"location":"guide/Core_Component/#c_1","text":"Source","title":"C"},{"location":"guide/Core_Component/#c_2","text":"Source | Package","title":"C#"},{"location":"guide/Election_Manifest/","text":"Election Manifest There are many types of elections. We need a base set of data that shows how these different types of elections are handled in an ElectionGuard end-to-end verifiable election (or ballot comparison audits). We worked with InfernoRed, VotingWorks, and Dan Wallach of Rice University (thanks folks!) to develop a set of conventions, tests, and sample data (based on a starting dataset sample from the Center for Civic Design) that demonstrate how to encode the information necessary to conduct an election into a format that ElectionGuard can use. The election terms and structure are based whenever possible on the NIST SP-1500-101 Election Event Logging Common Data Format Specification (with a prettier and (mostly) more functional implementation here and a PDF for version 2 ). The information captured by the NIST standard is codified into an election manifest that defines common elements when conducting an election, such as locations, candidates, parties, contests, and ballot styles. ElectionGuard uses the data contained in the Election Manifest to associate ballots with specific ballot styles and to verify the accuracy of data at different stages of the election process. Note that not all of the data contained in the Election Manifest impacts the computations of tallies and zero-knowledge proofs used in the published election data that demonstrates end-to-end verifiability; however it is important to include as much data as possible in order to distinguish one election from another. With a well-defined Election Manifest, improperly formatted ballot encryption requests will fail with error messages at the moment of initial encryption; the enforcement of any logic or behavior to prevent overvoting or other malformed ballot submissions are handled by the encrypting device, not ElectionGuard. In addition, since json files do not accommodate comments, all notations and exceptions are documented in this readme. Election Data Structure Elections are characterized into types by NIST as shown in the table below election type description general For an election held typically on the national day for elections. partisan-primary-closed For a primary election that is for a specific party where voter eligibility is based on registration. partisan-primary-open For a primary election that is for a specific party where voter declares desired party or chooses in private. primary For a primary election without a specified type, such as a nonpartisan primary. runoff For an election to decide a prior contest that ended with no candidate receiving a majority of the votes. special For an election held out of sequence for special circumstances, for example, to fill a vacated office. other Used when the election type is not listed in this enumeration. If used, include a specific value of the OtherType element. We present two sample manifests: general and partisan-primary-closed . The core distinction between the two samples is the role of party: in general elections voters can choose to vote for candidates from any party in a contest, regardless of party affiliation. In partisan primaries voters can only vote in contests germane to their party declaration or affiliation. As such, special , runoff , and primary election types will follow the general pattern, and partisan-primary-open will follow the partisan-primary-closed pattern. Open primary elections can follow either pattern as determined by their governing rules and regulations. (As noted above, ElectionGuard expects properly-formed ballots; e.g., it would error and fail to encrypt a ballot in an open-primary-closed election if a contest with an incorrect party affiliation were submitted (as indicated by the ).) Ballot Styles and Geography At least in the United States, many complications are introduced by voting simultaneously on election contests that apply in specific geographies and jurisdictions. For example, a single election could include contests for congress, state assembly, school, and utility districts, each with their own geographic boundaries, many that do not respect town or county lines. The ElectionGuard Election Manifest data format is flexible to accommodate most situations, but it is usually up to the election commission and the external system to determine what each component of the manifest actually means. In the following examples, we will work through the process of defining different election types at a high level and describe the process of building the election manifest. Geographic and Ballot Style Breakdown Each election can be thought of as a list of contests that are relevant to a certain group of people in a specific place. In order to determine who is supposed to vote on which contests, we first need to define the geographic jurisdictions where the election is taking place. The NIST Guidelines present an excellent discussion of the geographic interplay of different contests. The diagram from page 12 is presented below. As the diagram shows, congressional, state assembly, school district and other geographic boundaries project onto towns and municipalities in different ways. Elections manage this complexity by creating unique ballot styles that present to voters only the contests that pertain to them. Different jurisdictions use terms such as wards, precincts, and districts to describe the areas of overlap that guide ballot style creation. We will use precinct but ward and district could be used instead. Contests, Candidates and Parties In most cases, a resident of a specific precinct or location will expect to see a certain list of contests that are relevant to them. A contest is a specific collection of available choices ( selections ) from which the voter may choose some subset. For the ElectionGuard Election Manifest, each possible selection in a contest must be associated with a candidate, even for Referendum-style contests. If a contest also supports write-in values, then a write-in candidate is also defined. Candidates may also be associated with specific parties, but this is not required for all election types. Introducing Hamilton County, OZ To help disambiguate, let's explore an example. Geographic Jurisdictions Hamilton County includes 3 townships: LaCroix, Arlington, Harris. The town of LaCroix also has a utility district that comprises its own precinct for special referendums. Arlington has two distinct school districts. The county is also split into two congressional districts, district 5 and district 7. Harris township is entirely within Congressional District 5, but both LaCroix and Arlington are split between congressional districts 5 and 7. Building the Geographic Jurisdiction Mapping (Geopolitical Units) The Election Manifest includes an array of objects called geopoliticalUnits (a.k.a. gpUnit ). Each Geopolitical Unit must include the following fields: objectId - a unique identifier for the gpUnit. This value is used to map a contest to a specific jurisdiction name - the friendly name of the gp Unit type - they type of jurisdiction (one of the Reporting Unit Types ) contact information - the contact info for the geopolitical unit Geopolitical units are polygons on a map represented by legal jurisdictions. In our example Election Manifest for hamilton County, there is one geopolitical unit for each jurisdictional boundary in the image above: Hamilton County Congressional District 5 congressional District 7 LaCroix Township Exeter Utility District (within LaCroix Township) Harris Township Arlington Township Pismo Beach School District (within Arlington Township) Somerset School District (within Arlington Township) When defining the geopolitical units for an election, we define all of the possible geopolitical units for an election; even if there are no contests for a specific jurisdiction. This way, if contests are added or removed during the setup phase, you do not also have to remember to update the list of geopolitical units. Alternatively, you can define only the GP Units for which there are contests. The General Election Contests A general election will occur in Hamilton County. The county is voting along with the rest of the province, and the county is responsible for tabulating its own election results. This means that the Election Scope is defined at the county level. For the general election, the following sets of contests (and associated geographic boundaries) obtain: The National Contests - President and Vice President. This contest demonstrates a \"vote for the ticket\" and allows write-ins Province Contests - Governor - this contest demonstrates a long list of candidate names Congressional Contests - Congress Districts 5 and 7 - these contests demonstrate how to split a district using multiple ballot styles Township Contests - Retain Chief Justice - This contest demonstrates a contest that applies to a specific town whose boundaries are split across multiple ballot styles School District Contests - School Board - these contests demonstrate contests with multiple selections ( n-of-m ) and allow write-ins School Board, and Utility district referendum to show ballot style splits Utility District Contest - Utility District - This contest demonstrates a referendum-style contest with long descriptions and display language translation into Spanish Each contest must be associated with exactly ONE electoralDistrictId . The electoralDistrictId field on the contest is populated with the objectId of the associated Geopolitical Unit (e.g. the Contest congress-district-7-contest has the electoralDistrictId congress-district-7 Each contest must also define a sequenceOrder . the sequence order is an indexing mechanism used internally. It is not the sequence that the contests are displayed to the user . The order in which contests are displayed to the user is up to the implementing application. The General Election Ballot Styles A ballot style is the set of contests that a specific voter should see on their ballot for a given location. The ballot style is associated to the set of geopolitical units relevant to a specific point on a map. Since each contest is also associated with a geopolitical unit, a mapping is created between a point on a map and the contests that are relevant to that point. For instance, a voter that lives in the Exeter Utility District should see contests that are relevant to Congressional District 7, LaCroix Township and the Exeter Utility District. | Geopolitical Units are overlapping polygons, and ballot styles are the list of polygons relevant to a specific point on the map. Similar to Geopolitical Units, we define all of the possible ballot styles for an election in our example, even if there are no contests specific to a ballot style. This is subjective and the behavior may be different for the integrating system: Congressional District 7 Outside Any Township Congressional District 7 LaCroix Township Congressional District 7 LaCroix Township Exeter Utility District Congressional District 7 Arlington Township Congressional District 7 Arlington Township Pismo Beach School district Congressional District 7 Arlington Township Somerset School district Congressional District 5 Outside Any Township Congressional District 5 LaCroix Township Congressional District 5 Harris Township Congressional District 5 Arlington Township Pismo Beach School district Congressional District 5 Arlington Township Somerset School district By defining all of the possible ballot styles and all of the possible geopolitical units, we ensure that if a contest is added or removed, we only have to make sure the contest is correct. We do not have to modify the list of geopolitical units or ballot styles. Data Flexibility The relationship between a ballot style and the contests that are displayed on it are subjective to the implementing application. This example is just one way to define this relationship that is purposefully verbose. For instance, in our example we define a geopolitical unit as a set of overlapping polygons, and a ballot style as the intersection of those polygons at a specific point. This is a top-down approach. Alternatively, we could have defined a geopolitical unit as the intersection area of those polygons and mapped one ballot style to each geopolitical unit 1 to 1. for instance, instead of defining a single GP Unit each for: Congressional District 5, Congressional District 7, LaCroix Township, Exeter Utility district, etc; we could have instead defined the GP Units as: Congressional District 5 No Township Congressional District 7 No Township Congressional District 5 inside LaCroix Congressional District 5 Inside LaCroix and Exeter, etc. Then, instead of each Ballot Style having multiple GP Units, each ballot style would have applied to exactly one GP Unit. Data Validation When the election Manifest is loaded into ElectionGuard, its validity is checked semantically against the data format required to conduct an ElectionGuard Election. Specifically, we check that: Each Geopolitical Unit has a unique objectId Each Ballot Style maps to at least one valid Geopolitical Unit Each Party has a unique objectId Each Candidate either does not have a party, or is associated with a valid party Each Contest has a unique Sequence Order Each contest is associated with exactly one valid geopolitical unit Each contest has a valid number of selections for the number of seats in the contest Each selection on each contest is associated with a valid Candidate as long as the election manifest format matches the validation criteria, the election can proceed as an ElectionGuard election. Frequently Asked Questions Q: What if my ballot styles are not associated with geopolitical units? A: There are a few ways to handle this. In most cases, you can simply map the ballot style 1 to 1 to the geopolitical unit. for instance, if ballot-style-1 includes contest-1 then you may create geopolitical-unit-1 and associate both the ballot style and the contest to that geopolitical unit. This documentation is under review and subject to change. Please do not hesitate to open a github issue if you have questions, or find errors or omissions.","title":"Election Manifest"},{"location":"guide/Election_Manifest/#election-manifest","text":"There are many types of elections. We need a base set of data that shows how these different types of elections are handled in an ElectionGuard end-to-end verifiable election (or ballot comparison audits). We worked with InfernoRed, VotingWorks, and Dan Wallach of Rice University (thanks folks!) to develop a set of conventions, tests, and sample data (based on a starting dataset sample from the Center for Civic Design) that demonstrate how to encode the information necessary to conduct an election into a format that ElectionGuard can use. The election terms and structure are based whenever possible on the NIST SP-1500-101 Election Event Logging Common Data Format Specification (with a prettier and (mostly) more functional implementation here and a PDF for version 2 ). The information captured by the NIST standard is codified into an election manifest that defines common elements when conducting an election, such as locations, candidates, parties, contests, and ballot styles. ElectionGuard uses the data contained in the Election Manifest to associate ballots with specific ballot styles and to verify the accuracy of data at different stages of the election process. Note that not all of the data contained in the Election Manifest impacts the computations of tallies and zero-knowledge proofs used in the published election data that demonstrates end-to-end verifiability; however it is important to include as much data as possible in order to distinguish one election from another. With a well-defined Election Manifest, improperly formatted ballot encryption requests will fail with error messages at the moment of initial encryption; the enforcement of any logic or behavior to prevent overvoting or other malformed ballot submissions are handled by the encrypting device, not ElectionGuard. In addition, since json files do not accommodate comments, all notations and exceptions are documented in this readme.","title":"Election Manifest"},{"location":"guide/Election_Manifest/#election-data-structure","text":"Elections are characterized into types by NIST as shown in the table below election type description general For an election held typically on the national day for elections. partisan-primary-closed For a primary election that is for a specific party where voter eligibility is based on registration. partisan-primary-open For a primary election that is for a specific party where voter declares desired party or chooses in private. primary For a primary election without a specified type, such as a nonpartisan primary. runoff For an election to decide a prior contest that ended with no candidate receiving a majority of the votes. special For an election held out of sequence for special circumstances, for example, to fill a vacated office. other Used when the election type is not listed in this enumeration. If used, include a specific value of the OtherType element. We present two sample manifests: general and partisan-primary-closed . The core distinction between the two samples is the role of party: in general elections voters can choose to vote for candidates from any party in a contest, regardless of party affiliation. In partisan primaries voters can only vote in contests germane to their party declaration or affiliation. As such, special , runoff , and primary election types will follow the general pattern, and partisan-primary-open will follow the partisan-primary-closed pattern. Open primary elections can follow either pattern as determined by their governing rules and regulations. (As noted above, ElectionGuard expects properly-formed ballots; e.g., it would error and fail to encrypt a ballot in an open-primary-closed election if a contest with an incorrect party affiliation were submitted (as indicated by the ).)","title":"Election Data Structure"},{"location":"guide/Election_Manifest/#ballot-styles-and-geography","text":"At least in the United States, many complications are introduced by voting simultaneously on election contests that apply in specific geographies and jurisdictions. For example, a single election could include contests for congress, state assembly, school, and utility districts, each with their own geographic boundaries, many that do not respect town or county lines. The ElectionGuard Election Manifest data format is flexible to accommodate most situations, but it is usually up to the election commission and the external system to determine what each component of the manifest actually means. In the following examples, we will work through the process of defining different election types at a high level and describe the process of building the election manifest.","title":"Ballot Styles and Geography"},{"location":"guide/Election_Manifest/#geographic-and-ballot-style-breakdown","text":"Each election can be thought of as a list of contests that are relevant to a certain group of people in a specific place. In order to determine who is supposed to vote on which contests, we first need to define the geographic jurisdictions where the election is taking place. The NIST Guidelines present an excellent discussion of the geographic interplay of different contests. The diagram from page 12 is presented below. As the diagram shows, congressional, state assembly, school district and other geographic boundaries project onto towns and municipalities in different ways. Elections manage this complexity by creating unique ballot styles that present to voters only the contests that pertain to them. Different jurisdictions use terms such as wards, precincts, and districts to describe the areas of overlap that guide ballot style creation. We will use precinct but ward and district could be used instead.","title":"Geographic and Ballot Style Breakdown"},{"location":"guide/Election_Manifest/#contests-candidates-and-parties","text":"In most cases, a resident of a specific precinct or location will expect to see a certain list of contests that are relevant to them. A contest is a specific collection of available choices ( selections ) from which the voter may choose some subset. For the ElectionGuard Election Manifest, each possible selection in a contest must be associated with a candidate, even for Referendum-style contests. If a contest also supports write-in values, then a write-in candidate is also defined. Candidates may also be associated with specific parties, but this is not required for all election types.","title":"Contests, Candidates and Parties"},{"location":"guide/Election_Manifest/#introducing-hamilton-county-oz","text":"To help disambiguate, let's explore an example.","title":"Introducing Hamilton County, OZ"},{"location":"guide/Election_Manifest/#geographic-jurisdictions","text":"Hamilton County includes 3 townships: LaCroix, Arlington, Harris. The town of LaCroix also has a utility district that comprises its own precinct for special referendums. Arlington has two distinct school districts. The county is also split into two congressional districts, district 5 and district 7. Harris township is entirely within Congressional District 5, but both LaCroix and Arlington are split between congressional districts 5 and 7.","title":"Geographic Jurisdictions"},{"location":"guide/Election_Manifest/#building-the-geographic-jurisdiction-mapping-geopolitical-units","text":"The Election Manifest includes an array of objects called geopoliticalUnits (a.k.a. gpUnit ). Each Geopolitical Unit must include the following fields: objectId - a unique identifier for the gpUnit. This value is used to map a contest to a specific jurisdiction name - the friendly name of the gp Unit type - they type of jurisdiction (one of the Reporting Unit Types ) contact information - the contact info for the geopolitical unit Geopolitical units are polygons on a map represented by legal jurisdictions. In our example Election Manifest for hamilton County, there is one geopolitical unit for each jurisdictional boundary in the image above: Hamilton County Congressional District 5 congressional District 7 LaCroix Township Exeter Utility District (within LaCroix Township) Harris Township Arlington Township Pismo Beach School District (within Arlington Township) Somerset School District (within Arlington Township) When defining the geopolitical units for an election, we define all of the possible geopolitical units for an election; even if there are no contests for a specific jurisdiction. This way, if contests are added or removed during the setup phase, you do not also have to remember to update the list of geopolitical units. Alternatively, you can define only the GP Units for which there are contests.","title":"Building the Geographic Jurisdiction Mapping (Geopolitical Units)"},{"location":"guide/Election_Manifest/#the-general-election-contests","text":"A general election will occur in Hamilton County. The county is voting along with the rest of the province, and the county is responsible for tabulating its own election results. This means that the Election Scope is defined at the county level. For the general election, the following sets of contests (and associated geographic boundaries) obtain: The National Contests - President and Vice President. This contest demonstrates a \"vote for the ticket\" and allows write-ins Province Contests - Governor - this contest demonstrates a long list of candidate names Congressional Contests - Congress Districts 5 and 7 - these contests demonstrate how to split a district using multiple ballot styles Township Contests - Retain Chief Justice - This contest demonstrates a contest that applies to a specific town whose boundaries are split across multiple ballot styles School District Contests - School Board - these contests demonstrate contests with multiple selections ( n-of-m ) and allow write-ins School Board, and Utility district referendum to show ballot style splits Utility District Contest - Utility District - This contest demonstrates a referendum-style contest with long descriptions and display language translation into Spanish Each contest must be associated with exactly ONE electoralDistrictId . The electoralDistrictId field on the contest is populated with the objectId of the associated Geopolitical Unit (e.g. the Contest congress-district-7-contest has the electoralDistrictId congress-district-7 Each contest must also define a sequenceOrder . the sequence order is an indexing mechanism used internally. It is not the sequence that the contests are displayed to the user . The order in which contests are displayed to the user is up to the implementing application.","title":"The General Election Contests"},{"location":"guide/Election_Manifest/#the-general-election-ballot-styles","text":"A ballot style is the set of contests that a specific voter should see on their ballot for a given location. The ballot style is associated to the set of geopolitical units relevant to a specific point on a map. Since each contest is also associated with a geopolitical unit, a mapping is created between a point on a map and the contests that are relevant to that point. For instance, a voter that lives in the Exeter Utility District should see contests that are relevant to Congressional District 7, LaCroix Township and the Exeter Utility District. | Geopolitical Units are overlapping polygons, and ballot styles are the list of polygons relevant to a specific point on the map. Similar to Geopolitical Units, we define all of the possible ballot styles for an election in our example, even if there are no contests specific to a ballot style. This is subjective and the behavior may be different for the integrating system: Congressional District 7 Outside Any Township Congressional District 7 LaCroix Township Congressional District 7 LaCroix Township Exeter Utility District Congressional District 7 Arlington Township Congressional District 7 Arlington Township Pismo Beach School district Congressional District 7 Arlington Township Somerset School district Congressional District 5 Outside Any Township Congressional District 5 LaCroix Township Congressional District 5 Harris Township Congressional District 5 Arlington Township Pismo Beach School district Congressional District 5 Arlington Township Somerset School district By defining all of the possible ballot styles and all of the possible geopolitical units, we ensure that if a contest is added or removed, we only have to make sure the contest is correct. We do not have to modify the list of geopolitical units or ballot styles.","title":"The General Election Ballot Styles"},{"location":"guide/Election_Manifest/#data-flexibility","text":"The relationship between a ballot style and the contests that are displayed on it are subjective to the implementing application. This example is just one way to define this relationship that is purposefully verbose. For instance, in our example we define a geopolitical unit as a set of overlapping polygons, and a ballot style as the intersection of those polygons at a specific point. This is a top-down approach. Alternatively, we could have defined a geopolitical unit as the intersection area of those polygons and mapped one ballot style to each geopolitical unit 1 to 1. for instance, instead of defining a single GP Unit each for: Congressional District 5, Congressional District 7, LaCroix Township, Exeter Utility district, etc; we could have instead defined the GP Units as: Congressional District 5 No Township Congressional District 7 No Township Congressional District 5 inside LaCroix Congressional District 5 Inside LaCroix and Exeter, etc. Then, instead of each Ballot Style having multiple GP Units, each ballot style would have applied to exactly one GP Unit.","title":"Data Flexibility"},{"location":"guide/Election_Manifest/#data-validation","text":"When the election Manifest is loaded into ElectionGuard, its validity is checked semantically against the data format required to conduct an ElectionGuard Election. Specifically, we check that: Each Geopolitical Unit has a unique objectId Each Ballot Style maps to at least one valid Geopolitical Unit Each Party has a unique objectId Each Candidate either does not have a party, or is associated with a valid party Each Contest has a unique Sequence Order Each contest is associated with exactly one valid geopolitical unit Each contest has a valid number of selections for the number of seats in the contest Each selection on each contest is associated with a valid Candidate as long as the election manifest format matches the validation criteria, the election can proceed as an ElectionGuard election.","title":"Data Validation"},{"location":"guide/Election_Manifest/#frequently-asked-questions","text":"Q: What if my ballot styles are not associated with geopolitical units? A: There are a few ways to handle this. In most cases, you can simply map the ballot style 1 to 1 to the geopolitical unit. for instance, if ballot-style-1 includes contest-1 then you may create geopolitical-unit-1 and associate both the ballot style and the contest to that geopolitical unit. This documentation is under review and subject to change. Please do not hesitate to open a github issue if you have questions, or find errors or omissions.","title":"Frequently Asked Questions"},{"location":"guide/Glossary/","text":"ElectionGuard Glossary Overview ElectionGuard, end-to-end verifiability, and elections themselves use a variety of terms in the conductance of an election, as well as the encryption, tally, and publishing thereof. Many of these terms have variants used in different locales. Given the potential ambiguity of terminology, we present this Glossary. It states the precise meaning and usage of the terms used by the ElectionGuard SDK and related specifications and tools. Whenever possible, we used terms and meanings consistent the NIST Elections Guide . Terms Accepted Ballot A ballot that is accepted for inclusion in election results and is either: cast or spoiled. Auxiliary Key Pair Pair of keys (public & secret) used to encrypt/decrypt information sent between guardians Available Guardian A guardian that has announced as present for the decryption phase Ballot Box A collection of ballots that have been either cast or spoiled. Cast Ballot A ballot which a voter has accepted as valid to be included in the official election tally. Ciphertext Ballot An encrypted representation of a voter's filled-in ballot. Ciphertext Election Context The cryptographic context of an election that is configured during the Key Ceremony Compensated Decryption Share A partial decryption share value computed by an available guardian to compensate for a missing guardian so that the missing guardian's share can be generated and the election results can be successfully decrypted. Description Hash A hash representation of the original election description. Decryption Mediator A component or actor responsible for composing each guardian's partial decryptions or compensated decryptions into the plaintext tally Decryption Share A guardian's partial share of a decryption Election Description The election metadata that describes the structure and type of the election, including geopolitical units, contests, candidates, and ballot styles, etc. Encryption Device The device that is doing the encryption Election Key Pair Pair of keys (public & secret) used to encrypt/decrypt election Election Manifest The election metadata in json format that is parsed into an Election Description Election Partial Key Backup A point on a secret polynomial and commitments to verify this point for a designated guardian. Election Polynomial The election polynomial is the mathematical expression that each Guardian defines to solve for his or her private key. A different point associated with the polynomial is shared with each of the other guardians so that the guardians can come together to derive the polynomial function and solve for the private key. Encrypted Tally The homomorphically-combined and encrypted representation of all selections made for each option on every contest in the election. Guardian A guardian of the election who holds the ability to partially decrypt the election results Homomorphic Tally An encrypted representation of every selection on every ballot that was cast. Internal Election Description The subset of the election description required by ElectionGuard to validate ballots are correctly associated with an election. This component mutates the state of the Election Description. Joint Key Combined public key from election public keys of each guardian Key Ceremony The process conducted at the beginning of the election to create the joint encryption context for encrypting ballots during the election. Key Ceremony Mediator A mediator to mediate communication (if needed) of information such as keys between the guardians Missing Guardian A guardian who was configured during the Key Ceremony but who is not present for the decryption of the election results. Nonce A random number used to derive encryptions Plaintext Ballot The plaintext representation of a voter's selections Quorum The minimum count ( threshold ) of guardians that must be present in order to successfully decrypt the election results. Spoiled Ballot A ballot which a voter did not accept as valid and is not included in the tally. Tracking Code A unique hash value generated by an Encryption Device to anonymously identify a ballot Unknown Ballot A ballot which may not yet be determined as cast or spoiled, or that may have been spoiled but is otherwise not published in the election results.","title":"Glossary"},{"location":"guide/Glossary/#electionguard-glossary","text":"","title":"ElectionGuard Glossary"},{"location":"guide/Glossary/#overview","text":"ElectionGuard, end-to-end verifiability, and elections themselves use a variety of terms in the conductance of an election, as well as the encryption, tally, and publishing thereof. Many of these terms have variants used in different locales. Given the potential ambiguity of terminology, we present this Glossary. It states the precise meaning and usage of the terms used by the ElectionGuard SDK and related specifications and tools. Whenever possible, we used terms and meanings consistent the NIST Elections Guide .","title":"Overview"},{"location":"guide/Glossary/#terms","text":"","title":"Terms"},{"location":"guide/Glossary/#accepted-ballot","text":"A ballot that is accepted for inclusion in election results and is either: cast or spoiled.","title":"Accepted Ballot"},{"location":"guide/Glossary/#auxiliary-key-pair","text":"Pair of keys (public & secret) used to encrypt/decrypt information sent between guardians","title":"Auxiliary Key Pair"},{"location":"guide/Glossary/#available-guardian","text":"A guardian that has announced as present for the decryption phase","title":"Available Guardian"},{"location":"guide/Glossary/#ballot-box","text":"A collection of ballots that have been either cast or spoiled.","title":"Ballot Box"},{"location":"guide/Glossary/#cast-ballot","text":"A ballot which a voter has accepted as valid to be included in the official election tally.","title":"Cast Ballot"},{"location":"guide/Glossary/#ciphertext-ballot","text":"An encrypted representation of a voter's filled-in ballot.","title":"Ciphertext Ballot"},{"location":"guide/Glossary/#ciphertext-election-context","text":"The cryptographic context of an election that is configured during the Key Ceremony","title":"Ciphertext Election Context"},{"location":"guide/Glossary/#compensated-decryption-share","text":"A partial decryption share value computed by an available guardian to compensate for a missing guardian so that the missing guardian's share can be generated and the election results can be successfully decrypted.","title":"Compensated Decryption Share"},{"location":"guide/Glossary/#description-hash","text":"A hash representation of the original election description.","title":"Description Hash"},{"location":"guide/Glossary/#decryption-mediator","text":"A component or actor responsible for composing each guardian's partial decryptions or compensated decryptions into the plaintext tally","title":"Decryption Mediator"},{"location":"guide/Glossary/#decryption-share","text":"A guardian's partial share of a decryption","title":"Decryption Share"},{"location":"guide/Glossary/#election-description","text":"The election metadata that describes the structure and type of the election, including geopolitical units, contests, candidates, and ballot styles, etc.","title":"Election Description"},{"location":"guide/Glossary/#encryption-device","text":"The device that is doing the encryption","title":"Encryption Device"},{"location":"guide/Glossary/#election-key-pair","text":"Pair of keys (public & secret) used to encrypt/decrypt election","title":"Election Key Pair"},{"location":"guide/Glossary/#election-manifest","text":"The election metadata in json format that is parsed into an Election Description","title":"Election Manifest"},{"location":"guide/Glossary/#election-partial-key-backup","text":"A point on a secret polynomial and commitments to verify this point for a designated guardian.","title":"Election Partial Key Backup"},{"location":"guide/Glossary/#election-polynomial","text":"The election polynomial is the mathematical expression that each Guardian defines to solve for his or her private key. A different point associated with the polynomial is shared with each of the other guardians so that the guardians can come together to derive the polynomial function and solve for the private key.","title":"Election Polynomial"},{"location":"guide/Glossary/#encrypted-tally","text":"The homomorphically-combined and encrypted representation of all selections made for each option on every contest in the election.","title":"Encrypted Tally"},{"location":"guide/Glossary/#guardian","text":"A guardian of the election who holds the ability to partially decrypt the election results","title":"Guardian"},{"location":"guide/Glossary/#homomorphic-tally","text":"An encrypted representation of every selection on every ballot that was cast.","title":"Homomorphic Tally"},{"location":"guide/Glossary/#internal-election-description","text":"The subset of the election description required by ElectionGuard to validate ballots are correctly associated with an election. This component mutates the state of the Election Description.","title":"Internal Election Description"},{"location":"guide/Glossary/#joint-key","text":"Combined public key from election public keys of each guardian","title":"Joint Key"},{"location":"guide/Glossary/#key-ceremony","text":"The process conducted at the beginning of the election to create the joint encryption context for encrypting ballots during the election.","title":"Key Ceremony"},{"location":"guide/Glossary/#key-ceremony-mediator","text":"A mediator to mediate communication (if needed) of information such as keys between the guardians","title":"Key Ceremony Mediator"},{"location":"guide/Glossary/#missing-guardian","text":"A guardian who was configured during the Key Ceremony but who is not present for the decryption of the election results.","title":"Missing Guardian"},{"location":"guide/Glossary/#nonce","text":"A random number used to derive encryptions","title":"Nonce"},{"location":"guide/Glossary/#plaintext-ballot","text":"The plaintext representation of a voter's selections","title":"Plaintext Ballot"},{"location":"guide/Glossary/#quorum","text":"The minimum count ( threshold ) of guardians that must be present in order to successfully decrypt the election results.","title":"Quorum"},{"location":"guide/Glossary/#spoiled-ballot","text":"A ballot which a voter did not accept as valid and is not included in the tally.","title":"Spoiled Ballot"},{"location":"guide/Glossary/#tracking-code","text":"A unique hash value generated by an Encryption Device to anonymously identify a ballot","title":"Tracking Code"},{"location":"guide/Glossary/#unknown-ballot","text":"A ballot which may not yet be determined as cast or spoiled, or that may have been spoiled but is otherwise not published in the election results.","title":"Unknown Ballot"},{"location":"guide/Implementations/","text":"Reference Implementations These are reference implementations to showcase the scope of ElectionGuard. These repos can be seen as singular components or parts of the broader solution to fully verify an election. Web API A thin stateless API wrapping electionguard-python to perform ballot encryption, casting, spoiling, and tallying. Source | Docker | Documentation Archived Warning The following repositories are considered deprecated and are for research purposes not development. For active development, please look at non-archived section. Admin Device An application used to administer ElectionGuard election processes, including key generation, trustee provisioning, and post-election tallying, partial decryptions, and zero-knowledge proofs. Source Ballot Box Used to scan ballots to generate lists of cast and spoiled ballots in an election; used in tallying to finalize ballot operations (cast or spoil, etc.) for publishing results. Source Ballot Marking Device Working instance of ballot marking device (BMD). Built by VotingWorks in consultation with the Center for Civic Design , this front-end provides an interface for a voter to complete and print a ballot which, in an end-to-end verifiable use case, would be accompanied by a printed tracking ID. This BMD front-end is provided as one, potential implementation. Source Tracking Site An application that demonstrates publication of ElectionGuard election artifacts to a public website to enable verification ID lookup, downloadable zip files of the election result (for third-party verifiers), and election results summaries. Source Verifier The verifier application is used to perform an external, independent verification of an election tally. This repository contains a reference implementation of a verifier built against the ElectionGuard specifications. This is not meant to be the only verifier application, but rather an example. This library should be used in tandem with the technical specifications and usage guidelines contained in the specifications . Source","title":"Implementations"},{"location":"guide/Implementations/#reference-implementations","text":"These are reference implementations to showcase the scope of ElectionGuard. These repos can be seen as singular components or parts of the broader solution to fully verify an election.","title":"Reference Implementations"},{"location":"guide/Implementations/#web-api","text":"A thin stateless API wrapping electionguard-python to perform ballot encryption, casting, spoiling, and tallying. Source | Docker | Documentation","title":"Web API"},{"location":"guide/Implementations/#archived","text":"Warning The following repositories are considered deprecated and are for research purposes not development. For active development, please look at non-archived section.","title":"Archived"},{"location":"guide/Implementations/#admin-device","text":"An application used to administer ElectionGuard election processes, including key generation, trustee provisioning, and post-election tallying, partial decryptions, and zero-knowledge proofs. Source","title":"Admin Device"},{"location":"guide/Implementations/#ballot-box","text":"Used to scan ballots to generate lists of cast and spoiled ballots in an election; used in tallying to finalize ballot operations (cast or spoil, etc.) for publishing results. Source","title":"Ballot Box"},{"location":"guide/Implementations/#ballot-marking-device","text":"Working instance of ballot marking device (BMD). Built by VotingWorks in consultation with the Center for Civic Design , this front-end provides an interface for a voter to complete and print a ballot which, in an end-to-end verifiable use case, would be accompanied by a printed tracking ID. This BMD front-end is provided as one, potential implementation. Source","title":"Ballot Marking Device"},{"location":"guide/Implementations/#tracking-site","text":"An application that demonstrates publication of ElectionGuard election artifacts to a public website to enable verification ID lookup, downloadable zip files of the election result (for third-party verifiers), and election results summaries. Source","title":"Tracking Site"},{"location":"guide/Implementations/#verifier","text":"The verifier application is used to perform an external, independent verification of an election tally. This repository contains a reference implementation of a verifier built against the ElectionGuard specifications. This is not meant to be the only verifier application, but rather an example. This library should be used in tandem with the technical specifications and usage guidelines contained in the specifications . Source","title":"Verifier"},{"location":"guide/Overview/","text":"SDK The ElectionGuard software development kit (SDK) contains two major parts. The core component for developing with ElectionGuard and reference implementations that interact with core component or provide a peek into the pieces required for the election process. Specifications These documents contains the fundamental specifications, documentation, architecture, and mathematical/cryptographic proofs that underpin ElectionGuard. If you're looking to understand the system better, or want to know how to integrate the various components, there is a lot of valuable information contained here. v 1.0.0 Important This version is coming soon. Specification v 0.95.0 Specification v 0.85.0 Warning This version is deprecated. A new version is available. The basic process and concepts are still applicable. Specification","title":"Overview"},{"location":"guide/Overview/#sdk","text":"The ElectionGuard software development kit (SDK) contains two major parts. The core component for developing with ElectionGuard and reference implementations that interact with core component or provide a peek into the pieces required for the election process.","title":"SDK"},{"location":"guide/Overview/#specifications","text":"These documents contains the fundamental specifications, documentation, architecture, and mathematical/cryptographic proofs that underpin ElectionGuard. If you're looking to understand the system better, or want to know how to integrate the various components, there is a lot of valuable information contained here.","title":"Specifications"},{"location":"guide/Overview/#v-100","text":"Important This version is coming soon. Specification","title":"v 1.0.0"},{"location":"guide/Overview/#v-0950","text":"Specification","title":"v 0.95.0"},{"location":"guide/Overview/#v-0850","text":"Warning This version is deprecated. A new version is available. The basic process and concepts are still applicable. Specification","title":"v 0.85.0"},{"location":"guide/Verifiable_Election/","text":"Creating a Verifiable Election ElectionGuard is a software development kit (SDK) election system vendors can use to implement end-to-end verifiable (E2E-V) elections. Because it is designed to be integrated into both existing and new systems, it needs to be flexible. However, for end-to-end verifiability to be achieved, the following 3 core capabilities must be delivered: The voter is given a verification code they can use to verify their ballot was included in the final tally The voter has the means to challenge a ballot The election results and all its encrypted artifacts, including zero knowledge proofs, are published to enable full independent verifiability by third parties We describe each of these capabilities in detail below. Voter Verification Code A voter verification code is generated by the ballot encryption process of ElectionGuard. It is generated when the user has submitted their ballot to the voting system. Generating the Verification Code Submitting a ballot can mean virtually pressing a \"Submit\" button on a touchscreen voting device, inserting a paper ballot into a digital scanner, or some other event that causes a cast vote record to be generated in the voting system. From a user experience standpoint, the ballot encryption occurs at a point after the voter has filled out all contests they plan to, and has had a chance to review all their choices in a summary screen (or the completed paper ballot). In the ballot marking device use case, the ballot would be encrypted after the voter presses submit. For a ballot scanner, the cast vote record is generated after the scanner has interpreted the ballot. Please note that while the diagrams above show devices such as 'encrypted ballot server', ElectionGuard is intended to be run in an offline environment ; as such, if an API or server is used to listen for or communicate encryption requests, they are expected to be run locally in a secure environment. Once the ballot has been encrypted, the encrypting device needs to handle the verification code returned by the ballot encryption process and present it to the voter, ideally by printing it at the moment of creation in a format easy for the voter to take with them. When the election results are published (see \"Publishing election results\" below), these verification codes are published alongside, enabling them to see that their ballots were included in the election tally (or, in the case of Challenge Ballots, that they were included as challenge ballots (see \"Challenging a Ballot\" below)) The verification code format is a mix of human-readable words and alphanumeric codes. The first word is always human-readable to facilitate a search-like discovery experience (to try, go to our demo tracking site and begin typing 'coo' to surface the verification code above, or simply click the image to be taken directly). Challenging a ballot Encrypting a ballot and generating a verification code is the first step in an E2E-V process for the voter. For E2E-V compliance, the voter has to be offered the ability to challenge or \"spoil\" the ballot after the verification code has been generated and provided to the voter. When a ballot is challenged, it is no longer eligible to be included in the final tally. If the voter wants to register a vote after a challenge, they will need to begin the process again with a new ballot. In addition, when a ballot is challenged, the system must be able to perform a decryption of the challenged ballot and reveal its contents to the voter. Challenging of ballots increases the inherent security of the system, since the system has to assume that any ballot encrypted might have to be revealed, exposing any manipulation that may have occurred after submission; the system can't assume its actions will remain hidden. Individual voters can obtain as much confidence as they desire by challenging as many ballots as they wish. Although they won't ever be shown that the encryption of a cast ballot matches their selections, voters can see that every challenged ballot was correctly encrypted and committed to before the decision to cast or challenge was made. The ability to observe that all challenge ballots are correct thereby provides indirect evidence that cast ballots were also correct. Publishing Verifiable results When the election is complete and the results tallied, E2E-V elections publish the results so they can be verified independently. E2E-V election verifiers are written by third parties according to their interpretation of the ElectionGuard Specification . Any data published by an election should enable each and every cast encrypted ballot to be interrogated and tallied independently. From the spec: An ElectionGuard ballot is comprised entirely of encryptions of one (indicating selection made) and zero (indicating selection not made). Two things must be proven about the encryption of each vote: The encryption associated with each option is either an encryption of zero or an encryption of one. The sum of all encrypted values in a contest is equal to the selection limit for that contest (usually one). ElGamal encryption enables efficient zero-knowledge proofs of these requirements, and the Fiat-Shamir heuristic can be used to make these proofs non-interactive. Chaum-Pedersen proofs are used to demonstrate that an encryption is that of a specified value, and these are combined with the Cramer-Damg\u00e5rd-Schoenmakers technique to show that an encryption is that of one of a specified set of values \u2013particularly that a value is an encryption of either zero or one. The set of encryptions of selections in a contest are homomorphically combined, and the result is shown to be an encryption of that contest\u2019s selection limit, again using a Chaum-Pedersen proof. Once every ballot is proven to be properly formed (as above), all of the votes for each option are homomorphically summed to produce encryptions of the tallies for each option. The final step is then to decrypt these tallies and provide additional proofs that the decryption are correct. Showing Verification Code Results to Voters In addition to satisfying the data requirements for proper verification, any publishing exercise needs to also enable individual voters to query for the ballot that matches their verification code. Verification code results of cast ballots will indicate that the ballot was included in the final tally, and any associated metadata about the device that recorded the ballot (time, location, election, etc.; see example above). Challenge ballots are also published. Results for verification codes of challenge ballots should indicate that the ballot was not included in the election tally. Because the ballot is not included in the election tally, the contents can be decrypted and presented as well.","title":"Verifiable Election"},{"location":"guide/Verifiable_Election/#creating-a-verifiable-election","text":"ElectionGuard is a software development kit (SDK) election system vendors can use to implement end-to-end verifiable (E2E-V) elections. Because it is designed to be integrated into both existing and new systems, it needs to be flexible. However, for end-to-end verifiability to be achieved, the following 3 core capabilities must be delivered: The voter is given a verification code they can use to verify their ballot was included in the final tally The voter has the means to challenge a ballot The election results and all its encrypted artifacts, including zero knowledge proofs, are published to enable full independent verifiability by third parties We describe each of these capabilities in detail below.","title":"Creating a Verifiable Election"},{"location":"guide/Verifiable_Election/#voter-verification-code","text":"A voter verification code is generated by the ballot encryption process of ElectionGuard. It is generated when the user has submitted their ballot to the voting system.","title":"Voter Verification Code"},{"location":"guide/Verifiable_Election/#generating-the-verification-code","text":"Submitting a ballot can mean virtually pressing a \"Submit\" button on a touchscreen voting device, inserting a paper ballot into a digital scanner, or some other event that causes a cast vote record to be generated in the voting system. From a user experience standpoint, the ballot encryption occurs at a point after the voter has filled out all contests they plan to, and has had a chance to review all their choices in a summary screen (or the completed paper ballot). In the ballot marking device use case, the ballot would be encrypted after the voter presses submit. For a ballot scanner, the cast vote record is generated after the scanner has interpreted the ballot. Please note that while the diagrams above show devices such as 'encrypted ballot server', ElectionGuard is intended to be run in an offline environment ; as such, if an API or server is used to listen for or communicate encryption requests, they are expected to be run locally in a secure environment. Once the ballot has been encrypted, the encrypting device needs to handle the verification code returned by the ballot encryption process and present it to the voter, ideally by printing it at the moment of creation in a format easy for the voter to take with them. When the election results are published (see \"Publishing election results\" below), these verification codes are published alongside, enabling them to see that their ballots were included in the election tally (or, in the case of Challenge Ballots, that they were included as challenge ballots (see \"Challenging a Ballot\" below)) The verification code format is a mix of human-readable words and alphanumeric codes. The first word is always human-readable to facilitate a search-like discovery experience (to try, go to our demo tracking site and begin typing 'coo' to surface the verification code above, or simply click the image to be taken directly).","title":"Generating the Verification Code"},{"location":"guide/Verifiable_Election/#challenging-a-ballot","text":"Encrypting a ballot and generating a verification code is the first step in an E2E-V process for the voter. For E2E-V compliance, the voter has to be offered the ability to challenge or \"spoil\" the ballot after the verification code has been generated and provided to the voter. When a ballot is challenged, it is no longer eligible to be included in the final tally. If the voter wants to register a vote after a challenge, they will need to begin the process again with a new ballot. In addition, when a ballot is challenged, the system must be able to perform a decryption of the challenged ballot and reveal its contents to the voter. Challenging of ballots increases the inherent security of the system, since the system has to assume that any ballot encrypted might have to be revealed, exposing any manipulation that may have occurred after submission; the system can't assume its actions will remain hidden. Individual voters can obtain as much confidence as they desire by challenging as many ballots as they wish. Although they won't ever be shown that the encryption of a cast ballot matches their selections, voters can see that every challenged ballot was correctly encrypted and committed to before the decision to cast or challenge was made. The ability to observe that all challenge ballots are correct thereby provides indirect evidence that cast ballots were also correct.","title":"Challenging a ballot"},{"location":"guide/Verifiable_Election/#publishing-verifiable-results","text":"When the election is complete and the results tallied, E2E-V elections publish the results so they can be verified independently. E2E-V election verifiers are written by third parties according to their interpretation of the ElectionGuard Specification . Any data published by an election should enable each and every cast encrypted ballot to be interrogated and tallied independently. From the spec: An ElectionGuard ballot is comprised entirely of encryptions of one (indicating selection made) and zero (indicating selection not made). Two things must be proven about the encryption of each vote: The encryption associated with each option is either an encryption of zero or an encryption of one. The sum of all encrypted values in a contest is equal to the selection limit for that contest (usually one). ElGamal encryption enables efficient zero-knowledge proofs of these requirements, and the Fiat-Shamir heuristic can be used to make these proofs non-interactive. Chaum-Pedersen proofs are used to demonstrate that an encryption is that of a specified value, and these are combined with the Cramer-Damg\u00e5rd-Schoenmakers technique to show that an encryption is that of one of a specified set of values \u2013particularly that a value is an encryption of either zero or one. The set of encryptions of selections in a contest are homomorphically combined, and the result is shown to be an encryption of that contest\u2019s selection limit, again using a Chaum-Pedersen proof. Once every ballot is proven to be properly formed (as above), all of the votes for each option are homomorphically summed to produce encryptions of the tallies for each option. The final step is then to decrypt these tallies and provide additional proofs that the decryption are correct.","title":"Publishing Verifiable results"},{"location":"guide/Verifiable_Election/#showing-verification-code-results-to-voters","text":"In addition to satisfying the data requirements for proper verification, any publishing exercise needs to also enable individual voters to query for the ballot that matches their verification code. Verification code results of cast ballots will indicate that the ballot was included in the final tally, and any associated metadata about the device that recorded the ballot (time, location, election, etc.; see example above). Challenge ballots are also published. Results for verification codes of challenge ballots should indicate that the ballot was not included in the election tally. Because the ballot is not included in the election tally, the contents can be decrypted and presented as well.","title":"Showing Verification Code Results to Voters"}]}